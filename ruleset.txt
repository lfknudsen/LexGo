/* This is a block comment. You can also begin a line-comment with #.
 In order to keep the regular expressions delimited, comments cannot be preceded
 by anything but whitespace on their (first) line.

 Each line below is a separate rule.
 The format is <name>[(<type>)]<whitespace><regexp>.
 The actual regular expression used to read rulesets is in Expressions/ReadRuleset.txt.
 Note that the programme uses Google's RE2 engine, which is slightly limited in
 functionality in order to maintain O(n) time complexity;
 This means look-back and look-ahead is _not_ possible.

 The (type) information is optional, and currently (as of v0.9.0) does nothing.
 Rules have higher priority than ones listed below them. If two rules would
 theoretically match the same text, whichever one is highest will be selected. */
PKG(string)                 package
TYPE(string)                type
STRUCT(string)              struct
/* This is a multi-line comment :)
The strings below look complex, and that's because they are.
Without negative lookbehind, they have to be :( */
STRING(string)              "(?:(?:(?:(?:\\")|[^"])|\s)*[^\\])?"
STRING_SINGLE(string)       '(?:(?:(?:(?:\\')|[^'])|\s)*[^\\])?'
STRING_BACK(string)         `(?:(?:(?:(?:\\`)|[^`])|\s)*[^\\])?`
IDENT(string)               \p{L}+
INTEGER(int)                \d+
FLOAT(float)                \d+(\.\d+)?
# Remember to escape special symbols if you mean to use them as characters!
LPAREN(char)                \(
RPAREN(char)                \)
LBRace(char)                {
RBRACE(char)                }
LBRACKET(char)              \[
RBRACKET(char)              \]
OP_PLUS(char)               \+
OP_MINUS(char)              \-
OP_MUL(char)                \*
OP_DIV(char)                \/
OP_EQ(char)                 \=
OP_DEQ(string)              \=\=
COMMENT_LINE_START(char)    \#
COMMENT_BLOCK_START(string) \/\*
/* Some characters can be problematic, and do not follow normal rules of escaping with
 a backslash. You can enclose them in brackets instead. */
COMMENT_BLOCK_END(string)   [*][/]
/* ?: instead of a name means the regex will not be captured, meaning no token will
 be created based on it. The regex output of the following will be (?:\s+) */
?:(none)                    \s+
MISTAKE(string)             .+